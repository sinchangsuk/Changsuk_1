<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Tap Anywhere to Play (m4a, hardened)</title>
<style>
  html,body{height:100%;margin:0}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.7);color:#fff;font:16px/1.5 system-ui,-apple-system,Roboto,Arial,sans-serif;
    text-align:center;padding:24px;cursor:pointer;user-select:none}
  #hint{opacity:.8;font-size:13px;margin-top:6px}
</style>
</head>
<body>
  <div id="overlay">
    화면 아무 곳이나 한 번만 터치하면 재생됩니다 🎵
    <div id="hint">(iPhone: 무음 스위치/볼륨/사이트 음소거 확인)</div>
  </div>

<script>
(function(){
  const FILE_URL = "test.m4a"; // 같은 폴더 기준 (동일 출처 유지)

  // ---- 0) 요소/컨텍스트 준비 (전역 생성 X, 제스처 안에서 생성할 것들만 남겨둠)
  let started = false;

  // ---- 1) 제스처 핸들러: iOS에서 가장 안정적인 'touchend' 우선
  function bindOnce(){
    // passive:false 로 둬야 iOS가 '사용자 활성화'로 판정하는 케이스가 있음
    document.addEventListener('touchend', onGesture, { once:true, passive:false });
    document.addEventListener('click',    onGesture, { once:true });
    // 일부 안드로이드/데스크탑 대비
    document.addEventListener('mouseup',  onGesture, { once:true });
  }

  async function onGesture(ev){
    if (started) return; started = true;
    try {
      // ---- 2) Web Audio 언락 (가청 경로 열기)
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('AudioContext unsupported');
      const ctx = new AC();

      // 사용자 제스처 안에서 즉시 resume
      if (ctx.state === 'suspended') { await ctx.resume(); }

      // 초단기 무음 오실레이터로 오디오 경로를 '실제로' 울려줌 (일부 기기 필요)
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.value = 0.00001; // 사실상 무음
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      // 30ms 후 정지 (동기 체인 유지)
      setTimeout(()=>{ try{osc.stop();}catch(_){ } }, 30);

      // ---- 3) HTMLAudio를 제스처 안에서 동적 생성 + 즉시 play
      const a = new Audio();
      a.setAttribute('playsinline','');
      a.preload = 'auto';
      a.src = FILE_URL;   // 제스처 시점에 src 지정
      a.crossOrigin = 'anonymous'; // same-origin이지만 MediaElementSource 호환을 위해
      a.volume = 1.0;

      // MediaElementSource로 경유 → 일부 정책/디바이스에서 성공률↑
      const source = ctx.createMediaElementSource(a);
      source.connect(ctx.destination);

      // iOS가 첫 프레임 로딩 중 play 거부하는 케이스 방지: load 후 즉시 시도
      a.load();

      // 동기 컨텍스트에서 바로 호출 (await로 지연 만들지 않음)
      let playPromise;
      try {
        playPromise = a.play();
      } catch(eImmediate){
        // play()가 즉시 예외면 곧바로 WebAudio decode 폴백
        return fallbackDecode(ctx);
      }

      // 일부 브라우저는 Promise 반환 → 동기 흐름 유지하면서 처리
      if (playPromise && typeof playPromise.then === 'function') {
        let settled = false;
        playPromise.then(()=>{ settled = true; onSuccess(); })
                   .catch(async (_)=>{ await fallbackDecode(ctx); });

        // 1200ms 내 playing 이벤트가 안 오면 폴백 시도
        const timer = setTimeout(async ()=>{
          if (!settled && a.paused) { await fallbackDecode(ctx); }
        }, 1200);

        a.addEventListener('playing', ()=>{ clearTimeout(timer); onSuccess(); }, { once:true });
      } else {
        // Promise 미지원 브라우저: playing 이벤트로 판단
        const t = setTimeout(async ()=>{ if (a.paused) await fallbackDecode(ctx); }, 1200);
        a.addEventListener('playing', ()=>{ clearTimeout(t); onSuccess(); }, { once:true });
      }

      function onSuccess(){
        const ov = document.getElementById('overlay');
        if (ov) ov.style.display = 'none';
        // 앱 전환 후 복귀 시 끊기면 재시도
        document.addEventListener('visibilitychange', ()=>{
          if (!document.hidden && a.paused) { a.play().catch(()=>{}); }
        });
      }

      // ---- 4) 최후 폴백: WebAudio로 m4a 직접 디코딩 후 재생
      async function fallbackDecode(ctxInstance){
        // 이미 overlay 문구 업데이트
        const ov = document.getElementById('overlay');
        if (ov) ov.firstChild.textContent = '재생 준비중… (폴백 중)';

        try {
          const resp = await fetch(FILE_URL, { cache: 'force-cache' });
          if (!resp.ok) throw new Error('HTTP '+resp.status);
          const arr = await resp.arrayBuffer();

          const buf = await new Promise((res, rej)=> {
            try { ctxInstance.decodeAudioData(arr, res, rej); }
            catch(e){ rej(e); }
          });

          const node = ctxInstance.createBufferSource();
          node.buffer = buf;
          node.connect(ctxInstance.destination);
          node.start(0);

          if (ov) ov.style.display = 'none';
        } catch(e) {
          // 그래도 실패 → 사용자 환경 이슈 (무음 스위치/사이트 음소거 등)
          if (ov) ov.firstChild.textContent = '재생 실패 ❌  (무음 스위치/볼륨/사이트 음소거 확인 후 다시 터치)';
          started = false; // 재시도 허용
          bindOnce();
        }
      }

    } catch(eOuter) {
      // AudioContext조차 안되면 마지막 안내
      const ov = document.getElementById('overlay');
      if (ov) ov.firstChild.textContent = '재생 실패 ❌  (브라우저/OS 제한)';
      started = false;
      bindOnce();
    }
  }

  bindOnce(); // 초기 바인딩
})();
</script>
</body>
</html>
